# 002_BFF移行タスク分解

## 目的と背景
- ADR 001 で決定した Next.js Route Handler を BFF として採用する方針と、ADR 002 の OpenAPI/Orval による型自動生成方針を、実装タスクに落とし込む。
- API の OpenAPI 定義を単一ソースに据え、フロントエンド・BFF で共通利用する型/クライアントを自動生成する。
- フロントエンドの Route Handler を BFF 的に扱い、外部 API へのアクセスをサーバー側に寄せてセキュリティと責務分離を高める。

## スコープ
- モノレポにおける API (`api`)、フロントエンド (`frontend`)、MCP/拡張向け型共有の運用設計。
- OpenAPI の生成・配布フロー（生成元、配置場所、生成スクリプト、CI 組み込み）。
- BFF (Next.js Route Handler) でのデータ取得・正規化・エラー処理・キャッシュ方針。
- フロントエンドでの呼び出し口の差し替えと型の共有導線。

## 段階的タスク
### Phase 1: OpenAPI 生成と型配布のパイプライン確立
- `api/openapi.yaml` を単一ソースとして生成するコマンドを整備（例: `pnpm run openapi:gen`）。生成元/責務分離を README/ADR に明記。
- Orval 設定で API/BFF/フロント向けの生成先を決定し、モノレポ内の依存関係を固定（例: `api` → `frontend/src/lib/openapi` へ `pnpm run orval`）。
- CI で OpenAPI/Orval の乖離検知（未コミット生成物の差分チェック）を組み込み、手元での実行手順を docs に追加。

### Phase 2: BFF (Route Handler) 実装基盤
- Next.js Route Handler 向けの BFF クライアントを Orval 生成に含め、サーバー専用クライアントとフロント用クライアントのビルド設定を分離。
- BFF での共通関数を整備（認証ヘッダー付与、エラー正規化、ステータスコードのマッピング、ログ/メトリクスのフック点）。
- キャッシュ/再検証方針を決定（Route Handler の応答に `Cache-Control` を付与、サーバー内 fetch で `next.revalidate`/`cache: 'no-store'` などを使い分け）。
- `.env` の取り扱いルールを明示し、外部 API キーがクライアントに流出しないことを確認。

### Phase 3: フロントエンド呼び出しの BFF 置換
- 影響範囲の高いフローから順次 BFF 経由に差し替え（クエリ hooks/サーバーアクション/SSR などパターン別にガイド化）。
- 型の参照元を OpenAPI 生成物に寄せ、既存の重複型を整理。不要になったクライアント実装を段階的に除去。
- BFF での正規化レスポンスに合わせた UI 側のエラーハンドリング/ローディング表現を更新。

### Phase 4: 品質保証と運用
- BFF 経由のエンドポイントに対するコントラクトテストを Vitest で追加（OpenAPI スナップショットを利用した schema チェックを検討）。
- CI での E2E/統合テストがある場合は BFF 経由へ切り替え、フロントのスタブ利用方針を更新。
- 運用手順のドキュメント化（`pnpm run openapi:gen`→`pnpm run orval`→`pnpm run lint`/`test` の実行順や、生成物コミットポリシー）。

## アウトプット（以降のIssueで対応）
- OpenAPI 生成と Orval 配布のスクリプト/設定追加。
- Next.js Route Handler の共通 BFF クライアント基盤とユーティリティ整備。
- フロントエンドの API 呼び出しを BFF 経由へ段階移行するための個別 Issue/PR（高優先フローから順次）。
- コントラクトテスト/統合テストの追加と CI への組み込み。

## 未決定事項・検討ポイント
- OpenAPI 生成のソース: Hono スキーマからの自動出力か、手書き YAML を維持するか。パフォーマンスとメンテ性を基準に選定。
- Orval の生成ターゲット: BFF 用はサーバー専用 fetch クライアントに分けるか、`frontend` 内の共有 lib としてまとめるか。
- キャッシュ戦略: ISR/`cache: 'force-cache'` をどこまで許容するか。API 側の ETag/Last-Modified を活用するか。

## 現状整理メモ（Phase 番号なしの参考情報）
### API（Hono/Workers）側
- ルート: `/api/bookmarks`（クエリ `label` でフィルタ）、`/unlabeled`、`/recent`、`/unrated`、`/:id/label`、`/bulk`、`/:id/favorite`(POST/DELETE)、`/favorites`、`/:id/read|unread`、`/batch-label`。ラベル系は `/api/labels`（一覧/POST）、`/cleanup`、`/:id` GET/PATCH/DELETE。
- スキーマ: `utils/validation.ts` の手書きバリデーション（ID/文字列/配列）が中心。Zod 等のスキーマは未導入で OpenAPI 生成箇所なし。レスポンス構造は `success` + `bookmarks/labels` + `message` などが多いが型定義はソース内に散在。
- エラー: `exceptions` で独自 Error クラスを定義し `createErrorResponseBody` で正規化しているが、フォーマットは OpenAPI で宣言されていない。HTTP ステータスは `toContentfulStatusCode` でマッピング。

### フロントエンド側（Next.js App Router）
- API 基点: `frontend/src/lib/api/config.ts` の `API_BASE_URL`（環境変数なければ Cloudflare 本番 URL）をクライアントから直接参照。
- 呼び出し箇所: `features/bookmarks/queries/api.ts` でブックマーク系 API を直接 fetch。`features/labels/queries/api.ts` と `features/labels/hooks/useLabels.ts` でラベル API を直接 fetch。`app/page.tsx` と `app/favorites/page.tsx` もページ内で直接 fetch。
- 型: `src/types/api.ts` や各ファイル内ローカル型でレスポンスを定義。共通 OpenAPI ベースの型共有はなし。`ApiError` はフロント独自実装。

### ギャップと論点（Phase1 以降で解消する前提）
- OpenAPI 未生成: Hono 側にスキーマ/アノテーションがなく、Orval の入力源がない。`api/openapi.yaml` はまだ存在せず、生成コマンドも未定義。
- レスポンス形式ばらつき: `success` あり/なし、`message`/`error` の形が統一されておらず、BFF で正規化方針を決める必要がある。
- クライアント直呼び: `API_BASE_URL` をクライアントで参照しており、BFF 経由に差し替える際は Route Handler で同等のエンドポイントを提供する段階的移行が必要。
- バリデーション粒度: `validateRequestBody` など最小限のチェックのみで、OpenAPI スキーマと連動した型保証がない。BFF での入力検証と API のスキーマ生成を同時に設計する必要がある。

## 具体方針（合意済みメモ）
1. OpenAPI→Orval→多層生成
   - Hono 側にスキーマを付け、`pnpm run openapi:gen` で `api/openapi.yaml` を生成するのを唯一のソースにする。
   - `pnpm run orval` で複数ターゲットを生成: ブラウザ向け（`frontend/src/lib/openapi/client` など）と Route Handler/BFF 向けサーバー専用 fetch（`frontend/src/lib/openapi/server` など）。API 側で使う型が必要なら `api/src/generated` へ同一 OpenAPI から出力。
   - 生成パスと fetch 設定を Orval で分け、依存を固定。CI で生成物の乖離チェックを行う。

2. BFF は「フロント内サーバー層」
   - Next.js Route Handler をフロントの BFF として扱い、Workers/Hono API への外向き呼び出しをここに集約。外部キーやヘッダー付与、レスポンス正規化、キャッシュ方針を Route Handler で統一。
   - Orval のサーバー向け生成物（Node/edge向け fetch 設定）を BFF で利用し、フロント用生成物はブラウザ fetch/React Query 前提で使い分ける。

3. BFF への置換ステップ（イメージ）
   - Step A: 共通の BFF クライアントとエラーハンドリング/正規化処理を Route Handler 層に用意。
   - Step B: 主要フロー（一覧・お気に入り・ラベル）から順に Route Handler を実装し、`/api/...` の内部エンドポイントを提供。
   - Step C: フロントの呼び出しを `API_BASE_URL` 直叩きから相対パス (`/api/...`) に差し替え、Orval のフロント用型を参照。
   - Step D: 旧クライアントや重複型を削除し、レスポンス正規化に合わせて UI 側のエラーハンドリング/ローディングを更新。
