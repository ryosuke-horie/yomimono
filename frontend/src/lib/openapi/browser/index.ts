/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Yomimono API
 * „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØÁÆ°ÁêÜ„ÇíË°å„ÅÜ Yomimono API „ÅÆ OpenAPI ÂÆöÁæ©„ÄÇ
„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ src/openapi/spec.ts „ÇíÂîØ‰∏Ä„ÅÆ„ÇΩ„Éº„Çπ„Å®„Åó„Å¶ÁîüÊàê„Åï„Çå„Åæ„Åô„ÄÇ
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssignLabelRequest,
  AssignLabelResponse,
  BatchLabelRequest,
  BatchLabelResponse,
  BookmarkListResponse,
  BulkBookmarksRequest,
  CreateLabelRequest,
  DbTestResponse,
  DevTestResponse,
  ErrorResponse,
  FavoriteBookmarksResponse,
  GetApiBookmarksParams,
  LabelCleanupResponse,
  LabelResponse,
  LabelsResponse,
  MessageResponse,
  RecentBookmarksResponse,
  RecentBookmarksSampleResponse,
  SeedClearResponse,
  SeedOptions,
  SeedRunResponse,
  SeedStatusResponse,
  SuccessResponse,
  UnlabeledBookmarksResponse,
  UnratedBookmarksResponse,
  UpdateLabelRequest
} from './schemas';

/**
 * @summary Êú™Ë™≠„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */
export type getApiBookmarksResponse200 = {
  data: BookmarkListResponse
  status: 200
}

export type getApiBookmarksResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiBookmarksResponseSuccess = (getApiBookmarksResponse200) & {
  headers: Headers;
};
export type getApiBookmarksResponseError = (getApiBookmarksResponse500) & {
  headers: Headers;
};

export type getApiBookmarksResponse = (getApiBookmarksResponseSuccess | getApiBookmarksResponseError)

export const getGetApiBookmarksUrl = (params?: GetApiBookmarksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bookmarks?${stringifiedParams}` : `/api/bookmarks`
}

export const getApiBookmarks = async (params?: GetApiBookmarksParams, options?: RequestInit): Promise<getApiBookmarksResponse> => {
  
  const res = await fetch(getGetApiBookmarksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiBookmarksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiBookmarksResponse
}





export const getGetApiBookmarksQueryKey = (params?: GetApiBookmarksParams,) => {
    return [
    `/api/bookmarks`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiBookmarksQueryOptions = <TData = Awaited<ReturnType<typeof getApiBookmarks>>, TError = ErrorResponse>(params?: GetApiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiBookmarksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiBookmarks>>> = ({ signal }) => getApiBookmarks(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiBookmarksQueryResult = NonNullable<Awaited<ReturnType<typeof getApiBookmarks>>>
export type GetApiBookmarksQueryError = ErrorResponse


export function useGetApiBookmarks<TData = Awaited<ReturnType<typeof getApiBookmarks>>, TError = ErrorResponse>(
 params: undefined |  GetApiBookmarksParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarks<TData = Awaited<ReturnType<typeof getApiBookmarks>>, TError = ErrorResponse>(
 params?: GetApiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarks<TData = Awaited<ReturnType<typeof getApiBookmarks>>, TError = ErrorResponse>(
 params?: GetApiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Êú™Ë™≠„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */

export function useGetApiBookmarks<TData = Awaited<ReturnType<typeof getApiBookmarks>>, TError = ErrorResponse>(
 params?: GetApiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiBookmarksQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Ë§áÊï∞Ë®ò‰∫ã„Å´„Åæ„Å®„ÇÅ„Å¶„É©„Éô„É´‰ªò„Åë
 */
export type putApiBookmarksBatchLabelResponse200 = {
  data: BatchLabelResponse
  status: 200
}

export type putApiBookmarksBatchLabelResponse400 = {
  data: ErrorResponse
  status: 400
}

export type putApiBookmarksBatchLabelResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type putApiBookmarksBatchLabelResponseSuccess = (putApiBookmarksBatchLabelResponse200) & {
  headers: Headers;
};
export type putApiBookmarksBatchLabelResponseError = (putApiBookmarksBatchLabelResponse400 | putApiBookmarksBatchLabelResponse500) & {
  headers: Headers;
};

export type putApiBookmarksBatchLabelResponse = (putApiBookmarksBatchLabelResponseSuccess | putApiBookmarksBatchLabelResponseError)

export const getPutApiBookmarksBatchLabelUrl = () => {


  

  return `/api/bookmarks/batch-label`
}

export const putApiBookmarksBatchLabel = async (batchLabelRequest: BatchLabelRequest, options?: RequestInit): Promise<putApiBookmarksBatchLabelResponse> => {
  
  const res = await fetch(getPutApiBookmarksBatchLabelUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      batchLabelRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putApiBookmarksBatchLabelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putApiBookmarksBatchLabelResponse
}




export const getPutApiBookmarksBatchLabelMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>, TError,{data: BatchLabelRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>, TError,{data: BatchLabelRequest}, TContext> => {

const mutationKey = ['putApiBookmarksBatchLabel'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>, {data: BatchLabelRequest}> = (props) => {
          const {data} = props ?? {};

          return  putApiBookmarksBatchLabel(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiBookmarksBatchLabelMutationResult = NonNullable<Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>>
    export type PutApiBookmarksBatchLabelMutationBody = BatchLabelRequest
    export type PutApiBookmarksBatchLabelMutationError = ErrorResponse

    /**
 * @summary Ë§áÊï∞Ë®ò‰∫ã„Å´„Åæ„Å®„ÇÅ„Å¶„É©„Éô„É´‰ªò„Åë
 */
export const usePutApiBookmarksBatchLabel = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>, TError,{data: BatchLabelRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiBookmarksBatchLabel>>,
        TError,
        {data: BatchLabelRequest},
        TContext
      > => {

      const mutationOptions = getPutApiBookmarksBatchLabelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄÊã¨ÁôªÈå≤
 */
export type postApiBookmarksBulkResponse200 = {
  data: MessageResponse
  status: 200
}

export type postApiBookmarksBulkResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiBookmarksBulkResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiBookmarksBulkResponseSuccess = (postApiBookmarksBulkResponse200) & {
  headers: Headers;
};
export type postApiBookmarksBulkResponseError = (postApiBookmarksBulkResponse400 | postApiBookmarksBulkResponse500) & {
  headers: Headers;
};

export type postApiBookmarksBulkResponse = (postApiBookmarksBulkResponseSuccess | postApiBookmarksBulkResponseError)

export const getPostApiBookmarksBulkUrl = () => {


  

  return `/api/bookmarks/bulk`
}

export const postApiBookmarksBulk = async (bulkBookmarksRequest: BulkBookmarksRequest, options?: RequestInit): Promise<postApiBookmarksBulkResponse> => {
  
  const res = await fetch(getPostApiBookmarksBulkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkBookmarksRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiBookmarksBulkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiBookmarksBulkResponse
}




export const getPostApiBookmarksBulkMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksBulk>>, TError,{data: BulkBookmarksRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksBulk>>, TError,{data: BulkBookmarksRequest}, TContext> => {

const mutationKey = ['postApiBookmarksBulk'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiBookmarksBulk>>, {data: BulkBookmarksRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiBookmarksBulk(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiBookmarksBulkMutationResult = NonNullable<Awaited<ReturnType<typeof postApiBookmarksBulk>>>
    export type PostApiBookmarksBulkMutationBody = BulkBookmarksRequest
    export type PostApiBookmarksBulkMutationError = ErrorResponse

    /**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄÊã¨ÁôªÈå≤
 */
export const usePostApiBookmarksBulk = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksBulk>>, TError,{data: BulkBookmarksRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiBookmarksBulk>>,
        TError,
        {data: BulkBookmarksRequest},
        TContext
      > => {

      const mutationOptions = getPostApiBookmarksBulkMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„Çä‰∏ÄË¶ß
 */
export type getApiBookmarksFavoritesResponse200 = {
  data: FavoriteBookmarksResponse
  status: 200
}

export type getApiBookmarksFavoritesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiBookmarksFavoritesResponseSuccess = (getApiBookmarksFavoritesResponse200) & {
  headers: Headers;
};
export type getApiBookmarksFavoritesResponseError = (getApiBookmarksFavoritesResponse500) & {
  headers: Headers;
};

export type getApiBookmarksFavoritesResponse = (getApiBookmarksFavoritesResponseSuccess | getApiBookmarksFavoritesResponseError)

export const getGetApiBookmarksFavoritesUrl = () => {


  

  return `/api/bookmarks/favorites`
}

export const getApiBookmarksFavorites = async ( options?: RequestInit): Promise<getApiBookmarksFavoritesResponse> => {
  
  const res = await fetch(getGetApiBookmarksFavoritesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiBookmarksFavoritesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiBookmarksFavoritesResponse
}





export const getGetApiBookmarksFavoritesQueryKey = () => {
    return [
    `/api/bookmarks/favorites`
    ] as const;
    }

    
export const getGetApiBookmarksFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiBookmarksFavoritesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiBookmarksFavorites>>> = ({ signal }) => getApiBookmarksFavorites({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiBookmarksFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiBookmarksFavorites>>>
export type GetApiBookmarksFavoritesQueryError = ErrorResponse


export function useGetApiBookmarksFavorites<TData = Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksFavorites>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksFavorites>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksFavorites<TData = Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksFavorites>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksFavorites>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksFavorites<TData = Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„Çä‰∏ÄË¶ß
 */

export function useGetApiBookmarksFavorites<TData = Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksFavorites>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiBookmarksFavoritesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÊúÄËøëÊó¢Ë™≠„Å´„Åó„Åü„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ
 */
export type getApiBookmarksRecentResponse200 = {
  data: RecentBookmarksResponse
  status: 200
}

export type getApiBookmarksRecentResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiBookmarksRecentResponseSuccess = (getApiBookmarksRecentResponse200) & {
  headers: Headers;
};
export type getApiBookmarksRecentResponseError = (getApiBookmarksRecentResponse500) & {
  headers: Headers;
};

export type getApiBookmarksRecentResponse = (getApiBookmarksRecentResponseSuccess | getApiBookmarksRecentResponseError)

export const getGetApiBookmarksRecentUrl = () => {


  

  return `/api/bookmarks/recent`
}

export const getApiBookmarksRecent = async ( options?: RequestInit): Promise<getApiBookmarksRecentResponse> => {
  
  const res = await fetch(getGetApiBookmarksRecentUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiBookmarksRecentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiBookmarksRecentResponse
}





export const getGetApiBookmarksRecentQueryKey = () => {
    return [
    `/api/bookmarks/recent`
    ] as const;
    }

    
export const getGetApiBookmarksRecentQueryOptions = <TData = Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiBookmarksRecentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiBookmarksRecent>>> = ({ signal }) => getApiBookmarksRecent({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiBookmarksRecentQueryResult = NonNullable<Awaited<ReturnType<typeof getApiBookmarksRecent>>>
export type GetApiBookmarksRecentQueryError = ErrorResponse


export function useGetApiBookmarksRecent<TData = Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksRecent>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksRecent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksRecent<TData = Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksRecent>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksRecent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksRecent<TData = Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÊúÄËøëÊó¢Ë™≠„Å´„Åó„Åü„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ
 */

export function useGetApiBookmarksRecent<TData = Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksRecent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiBookmarksRecentQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Êú™„É©„Éô„É´„ÅÆÊú™Ë™≠„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */
export type getApiBookmarksUnlabeledResponse200 = {
  data: UnlabeledBookmarksResponse
  status: 200
}

export type getApiBookmarksUnlabeledResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiBookmarksUnlabeledResponseSuccess = (getApiBookmarksUnlabeledResponse200) & {
  headers: Headers;
};
export type getApiBookmarksUnlabeledResponseError = (getApiBookmarksUnlabeledResponse500) & {
  headers: Headers;
};

export type getApiBookmarksUnlabeledResponse = (getApiBookmarksUnlabeledResponseSuccess | getApiBookmarksUnlabeledResponseError)

export const getGetApiBookmarksUnlabeledUrl = () => {


  

  return `/api/bookmarks/unlabeled`
}

export const getApiBookmarksUnlabeled = async ( options?: RequestInit): Promise<getApiBookmarksUnlabeledResponse> => {
  
  const res = await fetch(getGetApiBookmarksUnlabeledUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiBookmarksUnlabeledResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiBookmarksUnlabeledResponse
}





export const getGetApiBookmarksUnlabeledQueryKey = () => {
    return [
    `/api/bookmarks/unlabeled`
    ] as const;
    }

    
export const getGetApiBookmarksUnlabeledQueryOptions = <TData = Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiBookmarksUnlabeledQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>> = ({ signal }) => getApiBookmarksUnlabeled({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiBookmarksUnlabeledQueryResult = NonNullable<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>>
export type GetApiBookmarksUnlabeledQueryError = ErrorResponse


export function useGetApiBookmarksUnlabeled<TData = Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksUnlabeled<TData = Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksUnlabeled<TData = Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Êú™„É©„Éô„É´„ÅÆÊú™Ë™≠„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */

export function useGetApiBookmarksUnlabeled<TData = Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnlabeled>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiBookmarksUnlabeledQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Êú™Ë©ï‰æ°„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */
export type getApiBookmarksUnratedResponse200 = {
  data: UnratedBookmarksResponse
  status: 200
}

export type getApiBookmarksUnratedResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiBookmarksUnratedResponseSuccess = (getApiBookmarksUnratedResponse200) & {
  headers: Headers;
};
export type getApiBookmarksUnratedResponseError = (getApiBookmarksUnratedResponse500) & {
  headers: Headers;
};

export type getApiBookmarksUnratedResponse = (getApiBookmarksUnratedResponseSuccess | getApiBookmarksUnratedResponseError)

export const getGetApiBookmarksUnratedUrl = () => {


  

  return `/api/bookmarks/unrated`
}

export const getApiBookmarksUnrated = async ( options?: RequestInit): Promise<getApiBookmarksUnratedResponse> => {
  
  const res = await fetch(getGetApiBookmarksUnratedUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiBookmarksUnratedResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiBookmarksUnratedResponse
}





export const getGetApiBookmarksUnratedQueryKey = () => {
    return [
    `/api/bookmarks/unrated`
    ] as const;
    }

    
export const getGetApiBookmarksUnratedQueryOptions = <TData = Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiBookmarksUnratedQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiBookmarksUnrated>>> = ({ signal }) => getApiBookmarksUnrated({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiBookmarksUnratedQueryResult = NonNullable<Awaited<ReturnType<typeof getApiBookmarksUnrated>>>
export type GetApiBookmarksUnratedQueryError = ErrorResponse


export function useGetApiBookmarksUnrated<TData = Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksUnrated>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksUnrated>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksUnrated<TData = Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiBookmarksUnrated>>,
          TError,
          Awaited<ReturnType<typeof getApiBookmarksUnrated>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiBookmarksUnrated<TData = Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Êú™Ë©ï‰æ°„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß
 */

export function useGetApiBookmarksUnrated<TData = Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiBookmarksUnrated>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiBookmarksUnratedQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„ÇäÂâäÈô§
 */
export type deleteApiBookmarksIdFavoriteResponse200 = {
  data: SuccessResponse
  status: 200
}

export type deleteApiBookmarksIdFavoriteResponse400 = {
  data: ErrorResponse
  status: 400
}

export type deleteApiBookmarksIdFavoriteResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteApiBookmarksIdFavoriteResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteApiBookmarksIdFavoriteResponseSuccess = (deleteApiBookmarksIdFavoriteResponse200) & {
  headers: Headers;
};
export type deleteApiBookmarksIdFavoriteResponseError = (deleteApiBookmarksIdFavoriteResponse400 | deleteApiBookmarksIdFavoriteResponse404 | deleteApiBookmarksIdFavoriteResponse500) & {
  headers: Headers;
};

export type deleteApiBookmarksIdFavoriteResponse = (deleteApiBookmarksIdFavoriteResponseSuccess | deleteApiBookmarksIdFavoriteResponseError)

export const getDeleteApiBookmarksIdFavoriteUrl = (id: number,) => {


  

  return `/api/bookmarks/${id}/favorite`
}

export const deleteApiBookmarksIdFavorite = async (id: number, options?: RequestInit): Promise<deleteApiBookmarksIdFavoriteResponse> => {
  
  const res = await fetch(getDeleteApiBookmarksIdFavoriteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteApiBookmarksIdFavoriteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteApiBookmarksIdFavoriteResponse
}




export const getDeleteApiBookmarksIdFavoriteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>, TError,{id: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteApiBookmarksIdFavorite'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiBookmarksIdFavorite(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiBookmarksIdFavoriteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>>
    
    export type DeleteApiBookmarksIdFavoriteMutationError = ErrorResponse

    /**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„ÇäÂâäÈô§
 */
export const useDeleteApiBookmarksIdFavorite = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>, TError,{id: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiBookmarksIdFavorite>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteApiBookmarksIdFavoriteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„ÇäËøΩÂä†
 */
export type postApiBookmarksIdFavoriteResponse200 = {
  data: SuccessResponse
  status: 200
}

export type postApiBookmarksIdFavoriteResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiBookmarksIdFavoriteResponse404 = {
  data: ErrorResponse
  status: 404
}

export type postApiBookmarksIdFavoriteResponse409 = {
  data: ErrorResponse
  status: 409
}

export type postApiBookmarksIdFavoriteResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiBookmarksIdFavoriteResponseSuccess = (postApiBookmarksIdFavoriteResponse200) & {
  headers: Headers;
};
export type postApiBookmarksIdFavoriteResponseError = (postApiBookmarksIdFavoriteResponse400 | postApiBookmarksIdFavoriteResponse404 | postApiBookmarksIdFavoriteResponse409 | postApiBookmarksIdFavoriteResponse500) & {
  headers: Headers;
};

export type postApiBookmarksIdFavoriteResponse = (postApiBookmarksIdFavoriteResponseSuccess | postApiBookmarksIdFavoriteResponseError)

export const getPostApiBookmarksIdFavoriteUrl = (id: number,) => {


  

  return `/api/bookmarks/${id}/favorite`
}

export const postApiBookmarksIdFavorite = async (id: number, options?: RequestInit): Promise<postApiBookmarksIdFavoriteResponse> => {
  
  const res = await fetch(getPostApiBookmarksIdFavoriteUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiBookmarksIdFavoriteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiBookmarksIdFavoriteResponse
}




export const getPostApiBookmarksIdFavoriteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>, TError,{id: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>, TError,{id: number}, TContext> => {

const mutationKey = ['postApiBookmarksIdFavorite'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postApiBookmarksIdFavorite(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiBookmarksIdFavoriteMutationResult = NonNullable<Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>>
    
    export type PostApiBookmarksIdFavoriteMutationError = ErrorResponse

    /**
 * @summary „ÅäÊ∞ó„Å´ÂÖ•„ÇäËøΩÂä†
 */
export const usePostApiBookmarksIdFavorite = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>, TError,{id: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiBookmarksIdFavorite>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostApiBookmarksIdFavoriteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å∏„É©„Éô„É´„Çí‰ªò‰∏é
 */
export type putApiBookmarksIdLabelResponse200 = {
  data: AssignLabelResponse
  status: 200
}

export type putApiBookmarksIdLabelResponse400 = {
  data: ErrorResponse
  status: 400
}

export type putApiBookmarksIdLabelResponse404 = {
  data: ErrorResponse
  status: 404
}

export type putApiBookmarksIdLabelResponse409 = {
  data: ErrorResponse
  status: 409
}

export type putApiBookmarksIdLabelResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type putApiBookmarksIdLabelResponseSuccess = (putApiBookmarksIdLabelResponse200) & {
  headers: Headers;
};
export type putApiBookmarksIdLabelResponseError = (putApiBookmarksIdLabelResponse400 | putApiBookmarksIdLabelResponse404 | putApiBookmarksIdLabelResponse409 | putApiBookmarksIdLabelResponse500) & {
  headers: Headers;
};

export type putApiBookmarksIdLabelResponse = (putApiBookmarksIdLabelResponseSuccess | putApiBookmarksIdLabelResponseError)

export const getPutApiBookmarksIdLabelUrl = (id: number,) => {


  

  return `/api/bookmarks/${id}/label`
}

export const putApiBookmarksIdLabel = async (id: number,
    assignLabelRequest: AssignLabelRequest, options?: RequestInit): Promise<putApiBookmarksIdLabelResponse> => {
  
  const res = await fetch(getPutApiBookmarksIdLabelUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignLabelRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putApiBookmarksIdLabelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putApiBookmarksIdLabelResponse
}




export const getPutApiBookmarksIdLabelMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksIdLabel>>, TError,{id: number;data: AssignLabelRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksIdLabel>>, TError,{id: number;data: AssignLabelRequest}, TContext> => {

const mutationKey = ['putApiBookmarksIdLabel'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiBookmarksIdLabel>>, {id: number;data: AssignLabelRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putApiBookmarksIdLabel(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiBookmarksIdLabelMutationResult = NonNullable<Awaited<ReturnType<typeof putApiBookmarksIdLabel>>>
    export type PutApiBookmarksIdLabelMutationBody = AssignLabelRequest
    export type PutApiBookmarksIdLabelMutationError = ErrorResponse

    /**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å∏„É©„Éô„É´„Çí‰ªò‰∏é
 */
export const usePutApiBookmarksIdLabel = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiBookmarksIdLabel>>, TError,{id: number;data: AssignLabelRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiBookmarksIdLabel>>,
        TError,
        {id: number;data: AssignLabelRequest},
        TContext
      > => {

      const mutationOptions = getPutApiBookmarksIdLabelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÊó¢Ë™≠„Å´„Åô„Çã
 */
export type patchApiBookmarksIdReadResponse200 = {
  data: SuccessResponse
  status: 200
}

export type patchApiBookmarksIdReadResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiBookmarksIdReadResponse404 = {
  data: ErrorResponse
  status: 404
}

export type patchApiBookmarksIdReadResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type patchApiBookmarksIdReadResponseSuccess = (patchApiBookmarksIdReadResponse200) & {
  headers: Headers;
};
export type patchApiBookmarksIdReadResponseError = (patchApiBookmarksIdReadResponse400 | patchApiBookmarksIdReadResponse404 | patchApiBookmarksIdReadResponse500) & {
  headers: Headers;
};

export type patchApiBookmarksIdReadResponse = (patchApiBookmarksIdReadResponseSuccess | patchApiBookmarksIdReadResponseError)

export const getPatchApiBookmarksIdReadUrl = (id: number,) => {


  

  return `/api/bookmarks/${id}/read`
}

export const patchApiBookmarksIdRead = async (id: number, options?: RequestInit): Promise<patchApiBookmarksIdReadResponse> => {
  
  const res = await fetch(getPatchApiBookmarksIdReadUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchApiBookmarksIdReadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchApiBookmarksIdReadResponse
}




export const getPatchApiBookmarksIdReadMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdRead>>, TError,{id: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdRead>>, TError,{id: number}, TContext> => {

const mutationKey = ['patchApiBookmarksIdRead'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiBookmarksIdRead>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  patchApiBookmarksIdRead(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiBookmarksIdReadMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiBookmarksIdRead>>>
    
    export type PatchApiBookmarksIdReadMutationError = ErrorResponse

    /**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÊó¢Ë™≠„Å´„Åô„Çã
 */
export const usePatchApiBookmarksIdRead = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdRead>>, TError,{id: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiBookmarksIdRead>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPatchApiBookmarksIdReadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÊú™Ë™≠„Å´Êàª„Åô
 */
export type patchApiBookmarksIdUnreadResponse200 = {
  data: SuccessResponse
  status: 200
}

export type patchApiBookmarksIdUnreadResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiBookmarksIdUnreadResponse404 = {
  data: ErrorResponse
  status: 404
}

export type patchApiBookmarksIdUnreadResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type patchApiBookmarksIdUnreadResponseSuccess = (patchApiBookmarksIdUnreadResponse200) & {
  headers: Headers;
};
export type patchApiBookmarksIdUnreadResponseError = (patchApiBookmarksIdUnreadResponse400 | patchApiBookmarksIdUnreadResponse404 | patchApiBookmarksIdUnreadResponse500) & {
  headers: Headers;
};

export type patchApiBookmarksIdUnreadResponse = (patchApiBookmarksIdUnreadResponseSuccess | patchApiBookmarksIdUnreadResponseError)

export const getPatchApiBookmarksIdUnreadUrl = (id: number,) => {


  

  return `/api/bookmarks/${id}/unread`
}

export const patchApiBookmarksIdUnread = async (id: number, options?: RequestInit): Promise<patchApiBookmarksIdUnreadResponse> => {
  
  const res = await fetch(getPatchApiBookmarksIdUnreadUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchApiBookmarksIdUnreadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchApiBookmarksIdUnreadResponse
}




export const getPatchApiBookmarksIdUnreadMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>, TError,{id: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>, TError,{id: number}, TContext> => {

const mutationKey = ['patchApiBookmarksIdUnread'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  patchApiBookmarksIdUnread(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiBookmarksIdUnreadMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>>
    
    export type PatchApiBookmarksIdUnreadMutationError = ErrorResponse

    /**
 * @summary „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÊú™Ë™≠„Å´Êàª„Åô
 */
export const usePatchApiBookmarksIdUnread = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>, TError,{id: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiBookmarksIdUnread>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPatchApiBookmarksIdUnreadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DB Êé•Á∂ö„ÉÜ„Çπ„Éà
 */
export type getApiDevDbTestResponse200 = {
  data: DbTestResponse
  status: 200
}

export type getApiDevDbTestResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiDevDbTestResponseSuccess = (getApiDevDbTestResponse200) & {
  headers: Headers;
};
export type getApiDevDbTestResponseError = (getApiDevDbTestResponse500) & {
  headers: Headers;
};

export type getApiDevDbTestResponse = (getApiDevDbTestResponseSuccess | getApiDevDbTestResponseError)

export const getGetApiDevDbTestUrl = () => {


  

  return `/api/dev/db-test`
}

export const getApiDevDbTest = async ( options?: RequestInit): Promise<getApiDevDbTestResponse> => {
  
  const res = await fetch(getGetApiDevDbTestUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiDevDbTestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiDevDbTestResponse
}





export const getGetApiDevDbTestQueryKey = () => {
    return [
    `/api/dev/db-test`
    ] as const;
    }

    
export const getGetApiDevDbTestQueryOptions = <TData = Awaited<ReturnType<typeof getApiDevDbTest>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiDevDbTestQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiDevDbTest>>> = ({ signal }) => getApiDevDbTest({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiDevDbTestQueryResult = NonNullable<Awaited<ReturnType<typeof getApiDevDbTest>>>
export type GetApiDevDbTestQueryError = ErrorResponse


export function useGetApiDevDbTest<TData = Awaited<ReturnType<typeof getApiDevDbTest>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevDbTest>>,
          TError,
          Awaited<ReturnType<typeof getApiDevDbTest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevDbTest<TData = Awaited<ReturnType<typeof getApiDevDbTest>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevDbTest>>,
          TError,
          Awaited<ReturnType<typeof getApiDevDbTest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevDbTest<TData = Awaited<ReturnType<typeof getApiDevDbTest>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary DB Êé•Á∂ö„ÉÜ„Çπ„Éà
 */

export function useGetApiDevDbTest<TData = Awaited<ReturnType<typeof getApiDevDbTest>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevDbTest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiDevDbTestQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÊúÄËøëËøΩÂä†„Åó„Åü„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØÁ¢∫Ë™ç
 */
export type getApiDevRecentBookmarksResponse200 = {
  data: RecentBookmarksSampleResponse
  status: 200
}

export type getApiDevRecentBookmarksResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiDevRecentBookmarksResponseSuccess = (getApiDevRecentBookmarksResponse200) & {
  headers: Headers;
};
export type getApiDevRecentBookmarksResponseError = (getApiDevRecentBookmarksResponse500) & {
  headers: Headers;
};

export type getApiDevRecentBookmarksResponse = (getApiDevRecentBookmarksResponseSuccess | getApiDevRecentBookmarksResponseError)

export const getGetApiDevRecentBookmarksUrl = () => {


  

  return `/api/dev/recent-bookmarks`
}

export const getApiDevRecentBookmarks = async ( options?: RequestInit): Promise<getApiDevRecentBookmarksResponse> => {
  
  const res = await fetch(getGetApiDevRecentBookmarksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiDevRecentBookmarksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiDevRecentBookmarksResponse
}





export const getGetApiDevRecentBookmarksQueryKey = () => {
    return [
    `/api/dev/recent-bookmarks`
    ] as const;
    }

    
export const getGetApiDevRecentBookmarksQueryOptions = <TData = Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiDevRecentBookmarksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>> = ({ signal }) => getApiDevRecentBookmarks({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiDevRecentBookmarksQueryResult = NonNullable<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>>
export type GetApiDevRecentBookmarksQueryError = ErrorResponse


export function useGetApiDevRecentBookmarks<TData = Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevRecentBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getApiDevRecentBookmarks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevRecentBookmarks<TData = Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevRecentBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getApiDevRecentBookmarks>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevRecentBookmarks<TData = Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÊúÄËøëËøΩÂä†„Åó„Åü„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØÁ¢∫Ë™ç
 */

export function useGetApiDevRecentBookmarks<TData = Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevRecentBookmarks>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiDevRecentBookmarksQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary „Ç∑„Éº„Éâ„Éá„Éº„Çø„ÇíÁîüÊàê
 */
export type postApiDevSeedResponse200 = {
  data: SeedRunResponse
  status: 200
}

export type postApiDevSeedResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiDevSeedResponseSuccess = (postApiDevSeedResponse200) & {
  headers: Headers;
};
export type postApiDevSeedResponseError = (postApiDevSeedResponse500) & {
  headers: Headers;
};

export type postApiDevSeedResponse = (postApiDevSeedResponseSuccess | postApiDevSeedResponseError)

export const getPostApiDevSeedUrl = () => {


  

  return `/api/dev/seed`
}

export const postApiDevSeed = async (seedOptions?: SeedOptions, options?: RequestInit): Promise<postApiDevSeedResponse> => {
  
  const res = await fetch(getPostApiDevSeedUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      seedOptions,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiDevSeedResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiDevSeedResponse
}




export const getPostApiDevSeedMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeed>>, TError,{data: SeedOptions}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeed>>, TError,{data: SeedOptions}, TContext> => {

const mutationKey = ['postApiDevSeed'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiDevSeed>>, {data: SeedOptions}> = (props) => {
          const {data} = props ?? {};

          return  postApiDevSeed(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiDevSeedMutationResult = NonNullable<Awaited<ReturnType<typeof postApiDevSeed>>>
    export type PostApiDevSeedMutationBody = SeedOptions
    export type PostApiDevSeedMutationError = ErrorResponse

    /**
 * @summary „Ç∑„Éº„Éâ„Éá„Éº„Çø„ÇíÁîüÊàê
 */
export const usePostApiDevSeed = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeed>>, TError,{data: SeedOptions}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiDevSeed>>,
        TError,
        {data: SeedOptions},
        TContext
      > => {

      const mutationOptions = getPostApiDevSeedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DB „Çí„ÇØ„É™„Ç¢
 */
export type postApiDevSeedClearResponse200 = {
  data: SeedClearResponse
  status: 200
}

export type postApiDevSeedClearResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiDevSeedClearResponseSuccess = (postApiDevSeedClearResponse200) & {
  headers: Headers;
};
export type postApiDevSeedClearResponseError = (postApiDevSeedClearResponse500) & {
  headers: Headers;
};

export type postApiDevSeedClearResponse = (postApiDevSeedClearResponseSuccess | postApiDevSeedClearResponseError)

export const getPostApiDevSeedClearUrl = () => {


  

  return `/api/dev/seed/clear`
}

export const postApiDevSeedClear = async ( options?: RequestInit): Promise<postApiDevSeedClearResponse> => {
  
  const res = await fetch(getPostApiDevSeedClearUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiDevSeedClearResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiDevSeedClearResponse
}




export const getPostApiDevSeedClearMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedClear>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedClear>>, TError,void, TContext> => {

const mutationKey = ['postApiDevSeedClear'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiDevSeedClear>>, void> = () => {
          

          return  postApiDevSeedClear(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiDevSeedClearMutationResult = NonNullable<Awaited<ReturnType<typeof postApiDevSeedClear>>>
    
    export type PostApiDevSeedClearMutationError = ErrorResponse

    /**
 * @summary DB „Çí„ÇØ„É™„Ç¢
 */
export const usePostApiDevSeedClear = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedClear>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiDevSeedClear>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostApiDevSeedClearMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „Ç´„Çπ„Çø„É†„Éë„É©„É°„Éº„Çø„Åß„Ç∑„Éº„ÉâÁîüÊàê
 */
export type postApiDevSeedCustomResponse200 = {
  data: SeedRunResponse
  status: 200
}

export type postApiDevSeedCustomResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiDevSeedCustomResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiDevSeedCustomResponseSuccess = (postApiDevSeedCustomResponse200) & {
  headers: Headers;
};
export type postApiDevSeedCustomResponseError = (postApiDevSeedCustomResponse400 | postApiDevSeedCustomResponse500) & {
  headers: Headers;
};

export type postApiDevSeedCustomResponse = (postApiDevSeedCustomResponseSuccess | postApiDevSeedCustomResponseError)

export const getPostApiDevSeedCustomUrl = () => {


  

  return `/api/dev/seed/custom`
}

export const postApiDevSeedCustom = async (seedOptions: SeedOptions, options?: RequestInit): Promise<postApiDevSeedCustomResponse> => {
  
  const res = await fetch(getPostApiDevSeedCustomUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      seedOptions,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiDevSeedCustomResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiDevSeedCustomResponse
}




export const getPostApiDevSeedCustomMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedCustom>>, TError,{data: SeedOptions}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedCustom>>, TError,{data: SeedOptions}, TContext> => {

const mutationKey = ['postApiDevSeedCustom'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiDevSeedCustom>>, {data: SeedOptions}> = (props) => {
          const {data} = props ?? {};

          return  postApiDevSeedCustom(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiDevSeedCustomMutationResult = NonNullable<Awaited<ReturnType<typeof postApiDevSeedCustom>>>
    export type PostApiDevSeedCustomMutationBody = SeedOptions
    export type PostApiDevSeedCustomMutationError = ErrorResponse

    /**
 * @summary „Ç´„Çπ„Çø„É†„Éë„É©„É°„Éº„Çø„Åß„Ç∑„Éº„ÉâÁîüÊàê
 */
export const usePostApiDevSeedCustom = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiDevSeedCustom>>, TError,{data: SeedOptions}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiDevSeedCustom>>,
        TError,
        {data: SeedOptions},
        TContext
      > => {

      const mutationOptions = getPostApiDevSeedCustomMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DB „ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
 */
export type getApiDevSeedStatusResponse200 = {
  data: SeedStatusResponse
  status: 200
}

export type getApiDevSeedStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiDevSeedStatusResponseSuccess = (getApiDevSeedStatusResponse200) & {
  headers: Headers;
};
export type getApiDevSeedStatusResponseError = (getApiDevSeedStatusResponse500) & {
  headers: Headers;
};

export type getApiDevSeedStatusResponse = (getApiDevSeedStatusResponseSuccess | getApiDevSeedStatusResponseError)

export const getGetApiDevSeedStatusUrl = () => {


  

  return `/api/dev/seed/status`
}

export const getApiDevSeedStatus = async ( options?: RequestInit): Promise<getApiDevSeedStatusResponse> => {
  
  const res = await fetch(getGetApiDevSeedStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiDevSeedStatusResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiDevSeedStatusResponse
}





export const getGetApiDevSeedStatusQueryKey = () => {
    return [
    `/api/dev/seed/status`
    ] as const;
    }

    
export const getGetApiDevSeedStatusQueryOptions = <TData = Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiDevSeedStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiDevSeedStatus>>> = ({ signal }) => getApiDevSeedStatus({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiDevSeedStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getApiDevSeedStatus>>>
export type GetApiDevSeedStatusQueryError = ErrorResponse


export function useGetApiDevSeedStatus<TData = Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevSeedStatus>>,
          TError,
          Awaited<ReturnType<typeof getApiDevSeedStatus>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevSeedStatus<TData = Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevSeedStatus>>,
          TError,
          Awaited<ReturnType<typeof getApiDevSeedStatus>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevSeedStatus<TData = Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary DB „ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
 */

export function useGetApiDevSeedStatus<TData = Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevSeedStatus>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiDevSeedStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary API Âãï‰ΩúÁ¢∫Ë™çÁî®„ÅÆÁ∞°Êòì„É¨„Çπ„Éù„É≥„Çπ
 */
export type getApiDevTestResponse200 = {
  data: DevTestResponse
  status: 200
}
    
export type getApiDevTestResponseSuccess = (getApiDevTestResponse200) & {
  headers: Headers;
};
;

export type getApiDevTestResponse = (getApiDevTestResponseSuccess)

export const getGetApiDevTestUrl = () => {


  

  return `/api/dev/test`
}

export const getApiDevTest = async ( options?: RequestInit): Promise<getApiDevTestResponse> => {
  
  const res = await fetch(getGetApiDevTestUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiDevTestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiDevTestResponse
}





export const getGetApiDevTestQueryKey = () => {
    return [
    `/api/dev/test`
    ] as const;
    }

    
export const getGetApiDevTestQueryOptions = <TData = Awaited<ReturnType<typeof getApiDevTest>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiDevTestQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiDevTest>>> = ({ signal }) => getApiDevTest({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiDevTestQueryResult = NonNullable<Awaited<ReturnType<typeof getApiDevTest>>>
export type GetApiDevTestQueryError = unknown


export function useGetApiDevTest<TData = Awaited<ReturnType<typeof getApiDevTest>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevTest>>,
          TError,
          Awaited<ReturnType<typeof getApiDevTest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevTest<TData = Awaited<ReturnType<typeof getApiDevTest>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiDevTest>>,
          TError,
          Awaited<ReturnType<typeof getApiDevTest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiDevTest<TData = Awaited<ReturnType<typeof getApiDevTest>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary API Âãï‰ΩúÁ¢∫Ë™çÁî®„ÅÆÁ∞°Êòì„É¨„Çπ„Éù„É≥„Çπ
 */

export function useGetApiDevTest<TData = Awaited<ReturnType<typeof getApiDevTest>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiDevTest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiDevTestQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary „É©„Éô„É´‰∏ÄË¶ß
 */
export type getApiLabelsResponse200 = {
  data: LabelsResponse
  status: 200
}

export type getApiLabelsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiLabelsResponseSuccess = (getApiLabelsResponse200) & {
  headers: Headers;
};
export type getApiLabelsResponseError = (getApiLabelsResponse500) & {
  headers: Headers;
};

export type getApiLabelsResponse = (getApiLabelsResponseSuccess | getApiLabelsResponseError)

export const getGetApiLabelsUrl = () => {


  

  return `/api/labels`
}

export const getApiLabels = async ( options?: RequestInit): Promise<getApiLabelsResponse> => {
  
  const res = await fetch(getGetApiLabelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiLabelsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiLabelsResponse
}





export const getGetApiLabelsQueryKey = () => {
    return [
    `/api/labels`
    ] as const;
    }

    
export const getGetApiLabelsQueryOptions = <TData = Awaited<ReturnType<typeof getApiLabels>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiLabelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiLabels>>> = ({ signal }) => getApiLabels({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiLabelsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiLabels>>>
export type GetApiLabelsQueryError = ErrorResponse


export function useGetApiLabels<TData = Awaited<ReturnType<typeof getApiLabels>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiLabels>>,
          TError,
          Awaited<ReturnType<typeof getApiLabels>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiLabels<TData = Awaited<ReturnType<typeof getApiLabels>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiLabels>>,
          TError,
          Awaited<ReturnType<typeof getApiLabels>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiLabels<TData = Awaited<ReturnType<typeof getApiLabels>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary „É©„Éô„É´‰∏ÄË¶ß
 */

export function useGetApiLabels<TData = Awaited<ReturnType<typeof getApiLabels>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabels>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiLabelsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary „É©„Éô„É´‰ΩúÊàê
 */
export type postApiLabelsResponse201 = {
  data: LabelResponse
  status: 201
}

export type postApiLabelsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postApiLabelsResponse409 = {
  data: ErrorResponse
  status: 409
}

export type postApiLabelsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postApiLabelsResponseSuccess = (postApiLabelsResponse201) & {
  headers: Headers;
};
export type postApiLabelsResponseError = (postApiLabelsResponse400 | postApiLabelsResponse409 | postApiLabelsResponse500) & {
  headers: Headers;
};

export type postApiLabelsResponse = (postApiLabelsResponseSuccess | postApiLabelsResponseError)

export const getPostApiLabelsUrl = () => {


  

  return `/api/labels`
}

export const postApiLabels = async (createLabelRequest: CreateLabelRequest, options?: RequestInit): Promise<postApiLabelsResponse> => {
  
  const res = await fetch(getPostApiLabelsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createLabelRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiLabelsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiLabelsResponse
}




export const getPostApiLabelsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLabels>>, TError,{data: CreateLabelRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiLabels>>, TError,{data: CreateLabelRequest}, TContext> => {

const mutationKey = ['postApiLabels'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiLabels>>, {data: CreateLabelRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiLabels(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiLabelsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiLabels>>>
    export type PostApiLabelsMutationBody = CreateLabelRequest
    export type PostApiLabelsMutationError = ErrorResponse

    /**
 * @summary „É©„Éô„É´‰ΩúÊàê
 */
export const usePostApiLabels = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLabels>>, TError,{data: CreateLabelRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiLabels>>,
        TError,
        {data: CreateLabelRequest},
        TContext
      > => {

      const mutationOptions = getPostApiLabelsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Êú™‰ΩøÁî®„É©„Éô„É´„ÅÆ‰∏ÄÊã¨ÂâäÈô§
 */
export type deleteApiLabelsCleanupResponse200 = {
  data: LabelCleanupResponse
  status: 200
}

export type deleteApiLabelsCleanupResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteApiLabelsCleanupResponseSuccess = (deleteApiLabelsCleanupResponse200) & {
  headers: Headers;
};
export type deleteApiLabelsCleanupResponseError = (deleteApiLabelsCleanupResponse500) & {
  headers: Headers;
};

export type deleteApiLabelsCleanupResponse = (deleteApiLabelsCleanupResponseSuccess | deleteApiLabelsCleanupResponseError)

export const getDeleteApiLabelsCleanupUrl = () => {


  

  return `/api/labels/cleanup`
}

export const deleteApiLabelsCleanup = async ( options?: RequestInit): Promise<deleteApiLabelsCleanupResponse> => {
  
  const res = await fetch(getDeleteApiLabelsCleanupUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteApiLabelsCleanupResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteApiLabelsCleanupResponse
}




export const getDeleteApiLabelsCleanupMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsCleanup>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsCleanup>>, TError,void, TContext> => {

const mutationKey = ['deleteApiLabelsCleanup'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiLabelsCleanup>>, void> = () => {
          

          return  deleteApiLabelsCleanup(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiLabelsCleanupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiLabelsCleanup>>>
    
    export type DeleteApiLabelsCleanupMutationError = ErrorResponse

    /**
 * @summary Êú™‰ΩøÁî®„É©„Éô„É´„ÅÆ‰∏ÄÊã¨ÂâäÈô§
 */
export const useDeleteApiLabelsCleanup = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsCleanup>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiLabelsCleanup>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteApiLabelsCleanupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary „É©„Éô„É´ÂâäÈô§
 */
export type deleteApiLabelsIdResponse200 = {
  data: MessageResponse
  status: 200
}

export type deleteApiLabelsIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type deleteApiLabelsIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteApiLabelsIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteApiLabelsIdResponseSuccess = (deleteApiLabelsIdResponse200) & {
  headers: Headers;
};
export type deleteApiLabelsIdResponseError = (deleteApiLabelsIdResponse400 | deleteApiLabelsIdResponse404 | deleteApiLabelsIdResponse500) & {
  headers: Headers;
};

export type deleteApiLabelsIdResponse = (deleteApiLabelsIdResponseSuccess | deleteApiLabelsIdResponseError)

export const getDeleteApiLabelsIdUrl = (id: number,) => {


  

  return `/api/labels/${id}`
}

export const deleteApiLabelsId = async (id: number, options?: RequestInit): Promise<deleteApiLabelsIdResponse> => {
  
  const res = await fetch(getDeleteApiLabelsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteApiLabelsIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteApiLabelsIdResponse
}




export const getDeleteApiLabelsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsId>>, TError,{id: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteApiLabelsId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiLabelsId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiLabelsId(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiLabelsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiLabelsId>>>
    
    export type DeleteApiLabelsIdMutationError = ErrorResponse

    /**
 * @summary „É©„Éô„É´ÂâäÈô§
 */
export const useDeleteApiLabelsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiLabelsId>>, TError,{id: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiLabelsId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteApiLabelsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary ID „Åß„É©„Éô„É´ÂèñÂæó
 */
export type getApiLabelsIdResponse200 = {
  data: LabelResponse
  status: 200
}

export type getApiLabelsIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getApiLabelsIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getApiLabelsIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getApiLabelsIdResponseSuccess = (getApiLabelsIdResponse200) & {
  headers: Headers;
};
export type getApiLabelsIdResponseError = (getApiLabelsIdResponse400 | getApiLabelsIdResponse404 | getApiLabelsIdResponse500) & {
  headers: Headers;
};

export type getApiLabelsIdResponse = (getApiLabelsIdResponseSuccess | getApiLabelsIdResponseError)

export const getGetApiLabelsIdUrl = (id: number,) => {


  

  return `/api/labels/${id}`
}

export const getApiLabelsId = async (id: number, options?: RequestInit): Promise<getApiLabelsIdResponse> => {
  
  const res = await fetch(getGetApiLabelsIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiLabelsIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiLabelsIdResponse
}





export const getGetApiLabelsIdQueryKey = (id?: number,) => {
    return [
    `/api/labels/${id}`
    ] as const;
    }

    
export const getGetApiLabelsIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiLabelsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiLabelsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiLabelsId>>> = ({ signal }) => getApiLabelsId(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiLabelsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiLabelsId>>>
export type GetApiLabelsIdQueryError = ErrorResponse


export function useGetApiLabelsId<TData = Awaited<ReturnType<typeof getApiLabelsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiLabelsId>>,
          TError,
          Awaited<ReturnType<typeof getApiLabelsId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiLabelsId<TData = Awaited<ReturnType<typeof getApiLabelsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiLabelsId>>,
          TError,
          Awaited<ReturnType<typeof getApiLabelsId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiLabelsId<TData = Awaited<ReturnType<typeof getApiLabelsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ID „Åß„É©„Éô„É´ÂèñÂæó
 */

export function useGetApiLabelsId<TData = Awaited<ReturnType<typeof getApiLabelsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiLabelsId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiLabelsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary „É©„Éô„É´Ë™¨ÊòéÊñá„ÅÆÊõ¥Êñ∞
 */
export type patchApiLabelsIdResponse200 = {
  data: LabelResponse
  status: 200
}

export type patchApiLabelsIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type patchApiLabelsIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type patchApiLabelsIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type patchApiLabelsIdResponseSuccess = (patchApiLabelsIdResponse200) & {
  headers: Headers;
};
export type patchApiLabelsIdResponseError = (patchApiLabelsIdResponse400 | patchApiLabelsIdResponse404 | patchApiLabelsIdResponse500) & {
  headers: Headers;
};

export type patchApiLabelsIdResponse = (patchApiLabelsIdResponseSuccess | patchApiLabelsIdResponseError)

export const getPatchApiLabelsIdUrl = (id: number,) => {


  

  return `/api/labels/${id}`
}

export const patchApiLabelsId = async (id: number,
    updateLabelRequest: UpdateLabelRequest, options?: RequestInit): Promise<patchApiLabelsIdResponse> => {
  
  const res = await fetch(getPatchApiLabelsIdUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateLabelRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchApiLabelsIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchApiLabelsIdResponse
}




export const getPatchApiLabelsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiLabelsId>>, TError,{id: number;data: UpdateLabelRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiLabelsId>>, TError,{id: number;data: UpdateLabelRequest}, TContext> => {

const mutationKey = ['patchApiLabelsId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiLabelsId>>, {id: number;data: UpdateLabelRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiLabelsId(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiLabelsIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiLabelsId>>>
    export type PatchApiLabelsIdMutationBody = UpdateLabelRequest
    export type PatchApiLabelsIdMutationError = ErrorResponse

    /**
 * @summary „É©„Éô„É´Ë™¨ÊòéÊñá„ÅÆÊõ¥Êñ∞
 */
export const usePatchApiLabelsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiLabelsId>>, TError,{id: number;data: UpdateLabelRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiLabelsId>>,
        TError,
        {id: number;data: UpdateLabelRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiLabelsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
